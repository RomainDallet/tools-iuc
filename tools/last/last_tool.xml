<tool id="last_tool" name="LAST" version="@LAST_CONDA_VERSION@+galaxy0" python_template_version="3.5">
    <description>finds similar regions between sequences.</description>
    <macros>
        <token name="@LAST_CONDA_VERSION@">1021</token>
    </macros>
    <requirements>
        <requirement type="package" version="@LAST_CONDA_VERSION@">last</requirement>
    </requirements>
    <command detect_errors="exit_code"><![CDATA[
        lastdb
        $lastdb.protein 
        $lastdb.repeats.uppercase$lastdb.repeats.simple_repeat
        $lastdb.repeats.sm_lower
        $lastdb.seeding_scheme
        $lastdb.lastdb_advanced.input_format
        $lastdb.lastdb_advanced.strand
        -w$lastdb.lastdb_advanced.step
        -W$lastdb.lastdb_advanced.size
        -i$lastdb.lastdb_advanced.matches
        $lastdb.lastdb_advanced.child_table
        ref_files
        '$ref_fasta'
        &&
        lastal
        $lastal.args_al
        ref_files
        '$int_fasta'
        $lastal.last_split
        > '$result'
    ]]></command>
    <inputs>
        <param name="ref_fasta" type="data" format="fasta" label="Reference sequence fasta file" />
        <param name="int_fasta" type="data" format="fasta" label="Sequence of interest fasta file" />
        <section name="lastdb" title="Lastdb arguments" expanded="true">
            <param name="protein" type="boolean" truevalue="-p" falsevalue="" checked="false" label="The sequences are proteins. (-p)"/>
            <section name="repeats" title="Specify lowercase-marking of repeats. (-R)" expanded="false">
                <param name="uppercase" type="boolean" truevalue="-R0" falsevalue="-R1" checked="false" label="Convert the input sequences to uppercase while reading them."/>
                <param name="simple_repeat" type="select" multiple="false" label="Check for simple repeats.">
                    <option value="0" selected="true">Do not check for simple repeats.</option>
                    <option value="1">Convert simple repeats to lowercase.</option>
                    <option value="2">Convert simple DNA repeats to lowercase</option>
                </param>
                <param name="sm_lower" type="boolean" truevalue="-c" falsevalue="" checked="true" label="Soft-mask lowercase letters. (-c)"/>
            </section>
            <param name="seeding_scheme" type="select" multiple="false" label="Specify a seeding scheme.">
                <option value="-uBISF">BISF</option>
                <option value="-uBISR">BISR</option>
                <option value="-uMAM4">MAM4</option>
                <option value="-uMAM8">MAM8</option>
                <option value="-uMURPHY10">MURPHY10</option>
                <option value="-uNEAR">NEAR</option>
                <option value="-uYASS" selected="true">YASS</option>
            </param>
            <section name="lastdb_advanced" title="Advanced options" expanded="false">
                <param name="input_format" type="select" multiple="false" label="Input format (-Q)">
                    <option value="-Q0" selected="true">fasta or fastq-ignore</option>
                    <option value="-Q1">fastq-sanger</option>
                    <option value="-Q2">fastq-solexa</option>
                    <option value="-Q3">fastq-illumina</option>
                </param>
                <param name="strand" type="select" multiple="false" label="Strand (-S)">
                    <option value="-S0">Reverse</option>
                    <option value="-S1" selected="true">Forward</option>
                    <option value="-S2">Both</option>
                </param>
                <param name="step" type="integer" value="1" label="Use initial matches starting at every w-th position in each sequence (-w)"/>
                <param name="size" type="integer" value="1" label="Use minimum positions in sliding windows of W consecutive positions (-W)"/>
                <param name="matches" type="integer" value="0" label="Minimum limit on initial matches per query position (-i)"/>
                <param name="child_table" type="select" multiple="false" label="Child table type (-C)">
                    <option value="-C0" selected="true">None</option>
                    <option value="-C1">Byte-size</option>
                    <option value="-C2">Short-syze</option>
                    <option value="-C3">Full</option>
                </param>
                <!--<param name="pattern" type="" value="1" label="-m"/>
                <param name="symbols" type="" label="-a"/>
                <param name="threads" type="integer" value="1" label="Divide the work between this number of threads running in parallel. 0 means use as many threads as your computer claims it can handle simultaneously. (-P)"/>
                <param name="mem_lim" type="" value="unlimited" label="-s"/>
                <param name="bucket_depth" type="" label="-b"/>
                <param name="count" type="" label="-x"/>
                <param name="verbose" type="" label="-v"/>-->
            </section>
        </section>
        <section name="lastal" title="Lastal arguments" expanded="true">
            <param name="output_format" type="select" multiple="false" label="Output format (-f)">
                <option value="-fMAF" selected="true">MAF</option>
                <option value="-fTAB">TAB</option>
                <option value="-fBlastTab">BlastTab</option>
                <option value="-fBlastTab+">BlastTab+</option>
            </param>
            <!--<param name="query_letters" type="integer" value="1e+06" label="Query letters per random alignment (-D)"/>
            <param name="max_eg2" type="integer" value="1e+18" label="Maximum expected alignments per square giga (-E)"/>-->
            <section name="score_options" title="Score options" expanded="false">
                <param name="match_score" type="integer" value="1" label="Match score (-r)"/>
                <param name="mismatch_cost" type="integer" value="1" label="Mismatch cost (-q)"/>
                <param name="args_al" type="select" multiple="false" label="Lastal arguments">
                    <option value="" selected="true">None</option>
                    <option value="-F15">Specify translated alignment with a score penalty of 15 for frameshifts (-F15)</option>
                    <option value="-pPAM30">Scoring scheme finds strong protein similarities (-pPAM30)</option>
                    <option value="-D100">Makes lastal report alignments that could occur by chance once per hundred query letters (-D100)</option>
                    <option value="-Q1">Indicates fastq-sanger format (-Q1)</option>
                    <option value="-j4">Estimate the ambiguity of each column in an alignment (-j4)</option>
                </param>
            </section>
            <param name="last_split" type="boolean" truevalue="| last-split" falsevalue="" checked="false" label="Looks for a unique best alignment for each part of each query." help="It allows different parts of one query to match different parts of the genome, which may happen due to rearrangements."/>
        </section>
    </inputs>
    <outputs>
        <data name="result" format="maf" />
    </outputs>
    <tests>
        <test>
            <param name="ref_fasta" value="humanMito.fa" />
            <param name="int_fasta" value="fuguMito.fa" />
            <param name="args_db" value="-cR01" />
            <output name="result" file="humanMito-fuguMito.maf" />
        </test>
    </tests>
    <help><![CDATA[
        LAST finds similar regions between sequences.

        The main technical innovation is that LAST finds initial matches based on their multiplicity, instead of using a fixed length (e.g. BLAST uses 11-mers). To find these variable-length matches, it uses a suffix array (inspired by Vmatch). To achieve high sensitivity, it uses a spaced suffix array (or subset suffix array), analogous to spaced seeds (or subset seeds).

        LAST can:
            - Handle big sequence data, e.g:
                - Compare two vertebrate genomes.
                - Align billions of DNA reads to a genome.
            - Indicate the reliability of each aligned column.
            - Use sequence quality data properly.
            - Compare DNA to proteins, with frameshifts.
            - Compare PSSMs to sequences.
            - Calculate the likelihood of chance similarities between random sequences.
            - Do split and spliced alignment.
            - Train alignment parameters for unusual kinds of sequence (e.g. nanopore).

    ]]></help>
    <citations></citations>
</tool>